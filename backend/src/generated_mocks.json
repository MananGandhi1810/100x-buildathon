{
  "app.py": {
    "language": "python",
    "mock_data": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport os\nimport streamlit as st\nfrom streamlit_chat import message\nfrom langchain_google_genai import GoogleGenerativeAIEmbeddings\nimport google.generativeai as genai\nfrom langchain_community.vectorstores import FAISS\nfrom langchain_google_genai import ChatGoogleGenerativeAI\nfrom langchain.chains.question_answering import load_qa_chain\nfrom langchain.prompts import PromptTemplate\n\n# Mock environment variables for testing\nos.environ[\"GOOGLE_API_KEY\"] = \"test_api_key\"\n\nclass TestFarmingExpertSystem(unittest.TestCase):\n\n    @patch('streamlit.set_page_config')\n    @patch('streamlit.title')\n    @patch('streamlit.subheader')\n    @patch('streamlit.selectbox')\n    @patch('streamlit.chat_input')\n    @patch('streamlit.chat_message')\n    @patch('streamlit.spinner')\n    @patch('streamlit.write')\n    @patch('streamlit.session_state')\n    @patch('streamlit.sidebar.subheader')\n    @patch('streamlit.sidebar.write')\n    @patch('streamlit.sidebar.warning')\n    @patch('streamlit.sidebar.info')\n    @patch('__main__.ask_question')\n    def test_main_happy_path(self, mock_ask_question, mock_info, mock_warning, mock_sidebar_write, mock_sidebar_subheader, mock_session_state, mock_write, mock_spinner, mock_chat_message, mock_chat_input, mock_selectbox, mock_subheader, mock_title, mock_set_page_config):\n        mock_ask_question.return_value = \"Test response\"\n        mock_selectbox.return_value = \"English\"\n        mock_chat_input.return_value = \"Test question\"\n        mock_session_state.messages = []\n\n        import __main__\n        __main__.main()\n\n        self.assertTrue(mock_ask_question.called)\n        self.assertEqual(len(mock_session_state.messages), 2)\n        self.assertEqual(mock_session_state.messages[0][\"content\"], \"Test question\")\n        self.assertEqual(mock_session_state.messages[1][\"content\"], \"Test response\")\n\n    @patch('streamlit.set_page_config')\n    @patch('streamlit.title')\n    @patch('streamlit.subheader')\n    @patch('streamlit.selectbox')\n    @patch('streamlit.chat_input')\n    @patch('streamlit.chat_message')\n    @patch('streamlit.spinner')\n    @patch('streamlit.write')\n    @patch('streamlit.session_state')\n    @patch('__main__.ask_question')\n    def test_main_error_in_ask_question(self, mock_ask_question, mock_session_state, mock_write, mock_spinner, mock_chat_message, mock_chat_input, mock_selectbox, mock_subheader, mock_title, mock_set_page_config):\n        mock_ask_question.return_value = \"I encountered an error while trying to answer your question. Please try again or check your setup.\"\n        mock_selectbox.return_value = \"English\"\n        mock_chat_input.return_value = \"Test question\"\n        mock_session_state.messages = []\n\n        import __main__\n        __main__.main()\n\n        self.assertTrue(mock_ask_question.called)\n        self.assertEqual(len(mock_session_state.messages), 2)\n        self.assertEqual(mock_session_state.messages[0][\"content\"], \"Test question\")\n        self.assertEqual(mock_session_state.messages[1][\"content\"], \"I encountered an error while trying to answer your question. Please try again or check your setup.\")\n\n    @patch('streamlit.set_page_config')\n    @patch('streamlit.title')\n    @patch('streamlit.subheader')\n    @patch('streamlit.selectbox')\n    @patch('streamlit.chat_input')\n    @patch('streamlit.chat_message')\n    @patch('streamlit.spinner')\n    @patch('streamlit.write')\n    @patch('streamlit.session_state')\n    @patch('__main__.ask_question')\n    def test_main_empty_input(self, mock_ask_question, mock_session_state, mock_write, mock_spinner, mock_chat_message, mock_chat_input, mock_selectbox, mock_subheader, mock_title, mock_set_page_config):\n        mock_ask_question.return_value = \"Test response\"\n        mock_selectbox.return_value = \"English\"\n        mock_chat_input.return_value = None  # Simulate no input\n        mock_session_state.messages = []\n\n        import __main__\n        __main__.main()\n\n        self.assertFalse(mock_ask_question.called) #ask_question not called, as there is no input\n        self.assertEqual(len(mock_session_state.messages), 0)\n\n\n    @patch('langchain_google_genai.ChatGoogleGenerativeAI')\n    @patch('langchain.chains.question_answering.load_qa_chain')\n    def test_get_conversational_chain_success(self, mock_load_qa_chain, mock_chat_model):\n        mock_chat_model_instance = MagicMock()\n        mock_chat_model.return_value = mock_chat_model_instance\n        mock_load_qa_chain_instance = MagicMock()\n        mock_load_qa_chain.return_value = mock_load_qa_chain_instance\n\n        import __main__\n        chain = __main__.get_conversational_chain()\n\n        self.assertIsNotNone(chain)\n        mock_chat_model.assert_called_once_with(model=\"gemini-1.5-flash-latest\", temperature=0.3)\n        mock_load_qa_chain.assert_called_once()\n\n    @patch('langchain_google_genai.ChatGoogleGenerativeAI')\n    @patch('langchain.chains.question_answering.load_qa_chain')\n    @patch('streamlit.error')\n    def test_get_conversational_chain_failure(self, mock_st_error, mock_load_qa_chain, mock_chat_model):\n        mock_load_qa_chain.side_effect = Exception(\"Test exception\")\n\n        import __main__\n        chain = __main__.get_conversational_chain()\n\n        self.assertIsNone(chain)\n        mock_st_error.assert_called_once()\n\n    @patch('langchain_google_genai.GoogleGenerativeAIEmbeddings')\n    @patch('langchain_community.vectorstores.FAISS.load_local')\n    @patch('__main__.get_conversational_chain')\n    def test_ask_question_success(self, mock_get_conversational_chain, mock_faiss_load, mock_embeddings):\n        mock_get_conversational_chain.return_value = MagicMock(return_value={'output_text': 'Test answer'})\n        mock_faiss_load.return_value.similarity_search.return_value = [\"doc1\", \"doc2\"]\n\n        import __main__\n        response = __main__.ask_question(\"Test question\", \"English\")\n\n        self.assertEqual(response, 'Test answer')\n        mock_faiss_load.assert_called_once()\n        mock_get_conversational_chain.assert_called_once()\n\n    @patch('langchain_google_genai.GoogleGenerativeAIEmbeddings')\n    @patch('langchain_community.vectorstores.FAISS.load_local')\n    @patch('__main__.get_conversational_chain')\n    def test_ask_question_error_in_chain(self, mock_get_conversational_chain, mock_faiss_load, mock_embeddings):\n         mock_get_conversational_chain.return_value = None #simulate chain creation failure\n         mock_faiss_load.return_value.similarity_search.return_value = [\"doc1\", \"doc2\"]\n\n         import __main__\n         response = __main__.ask_question(\"Test question\", \"English\")\n\n         self.assertEqual(response, \"Sorry, I'm having trouble generating a response. Please try again later.\")\n\n    @patch('langchain_google_genai.GoogleGenerativeAIEmbeddings')\n    @patch('langchain_community.vectorstores.FAISS.load_local')\n    @patch('__main__.get_conversational_chain')\n    @patch('streamlit.error')\n    def test_ask_question_failure(self, mock_st_error, mock_get_conversational_chain, mock_faiss_load, mock_embeddings):\n        mock_faiss_load.side_effect = Exception(\"Test exception\")\n\n        import __main__\n        response = __main__.ask_question(\"Test question\", \"English\")\n\n        self.assertEqual(response, \"I encountered an error while trying to answer your question. Please try again or check your setup.\")\n        mock_st_error.assert_called_once()\n\n    @patch('streamlit.error')\n    def test_api_key_not_found(self, mock_st_error):\n        original_api_key = os.environ.get(\"GOOGLE_API_KEY\")\n        if \"GOOGLE_API_KEY\" in os.environ:\n            del os.environ[\"GOOGLE_API_KEY\"]  # Remove the API key temporarily\n\n        import __main__\n        __main__.api_key = os.getenv(\"GOOGLE_API_KEY\")\n\n        if original_api_key:\n            os.environ[\"GOOGLE_API_KEY\"] = original_api_key #restore api key\n\n        self.assertIsNone(__main__.api_key)\n        mock_st_error.assert_called_once() #error message shown"
  },
  "add_pdfs.py": {
    "language": "python",
    "mock_data": "import unittest\nfrom unittest.mock import patch, mock_open\nimport os\nfrom io import StringIO\nfrom PyPDF2 import PdfReader\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\nfrom langchain_google_genai import GoogleGenerativeAIEmbeddings\nimport google.generativeai as genai\nfrom langchain_community.vectorstores import FAISS\nfrom dotenv import load_dotenv\n\n# Load environment variables\nload_dotenv()\n\n# Configure Google Generative AI\napi_key = os.getenv(\"GOOGLE_API_KEY\")\nif not api_key:\n    print(\"GOOGLE_API_KEY not found. Please set it in your .env file or environment variables.\")\n    exit(1)\n\n\ngenai.configure(api_key=api_key)\n\ndef get_pdf_text(pdf_path):\n    try:\n        with open(pdf_path, 'rb') as file:\n            pdf_reader = PdfReader(file)\n            text = \"\"\n            for page in pdf_reader.pages:\n                text += page.extract_text()\n        return text\n    except Exception as e:\n        print(f\"Error reading PDF {pdf_path}: {str(e)}\")\n        return \"\"\n\ndef get_text_chunks(text):\n    try:\n        splitter = RecursiveCharacterTextSplitter(\n            chunk_size=10000, chunk_overlap=1000)\n        chunks = splitter.split_text(text)\n        return chunks\n    except Exception as e:\n        print(f\"Error splitting text: {str(e)}\")\n        return []\n\ndef get_vector_store(chunks):\n    try:\n        embeddings = GoogleGenerativeAIEmbeddings(\n            model=\"models/embedding-001\")\n        vector_store = FAISS.from_texts(chunks, embedding=embeddings)\n        vector_store.save_local(\"faiss_index\")\n        return True\n    except Exception as e:\n        print(f\"Error creating vector store: {str(e)}\")\n        return False\n\ndef process_pdf(pdf_path):\n    print(f\"Processing PDF: {pdf_path}\")\n    raw_text = get_pdf_text(pdf_path)\n    if not raw_text:\n        print(\"No text extracted from PDF. Please check the file.\")\n        return\n\n    print(\"Splitting text into chunks...\")\n    text_chunks = get_text_chunks(raw_text)\n    if not text_chunks:\n        print(\"Failed to split text into chunks.\")\n        return\n\n    print(\"Creating vector store...\")\n    if get_vector_store(text_chunks):\n        print(\"PDF processing complete. Knowledge base updated.\")\n    else:\n        print(\"Failed to update knowledge base.\")\n\ndef main():\n    while True:\n        pdf_path = input(\"Enter the path to the PDF file (or 'q' to quit): \").strip()\n        \n        if pdf_path.lower() == 'q':\n            print(\"Exiting the program.\")\n            break\n\n        if not os.path.exists(pdf_path):\n            print(f\"File not found: {pdf_path}\")\n            continue\n\n        process_pdf(pdf_path)\n\n        another = input(\"Do you want to process another PDF? (y/n): \").strip().lower()\n        if another != 'y':\n            print(\"Exiting the program.\")\n            break\n\nif __name__ == \"__main__\":\n    print(\"Welcome to the Farming Equipment Manual Uploader!\")\n    print(\"This program will process PDF manuals and update the knowledge base.\")\n    main()\n\nclass TestPDFProcessing(unittest.TestCase):\n\n    @patch('os.path.exists')\n    @patch('builtins.input', side_effect=['q'])\n    @patch('builtins.print')\n    def test_main_quit(self, mock_print, mock_input, mock_exists):\n        mock_exists.return_value = True\n        main()\n        mock_print.assert_any_call(\"Exiting the program.\")\n\n    @patch('os.path.exists', return_value=False)\n    @patch('builtins.input', side_effect=['nonexistent.pdf', 'q'])\n    @patch('builtins.print')\n    def test_main_file_not_found(self, mock_print, mock_input, mock_exists):\n        main()\n        mock_print.assert_any_call(\"File not found: nonexistent.pdf\")\n        mock_print.assert_any_call(\"Exiting the program.\")\n\n    @patch('os.path.exists', return_value=True)\n    @patch('builtins.input', side_effect=['valid.pdf', 'n'])\n    @patch('__main__.process_pdf')\n    @patch('builtins.print')\n    def test_main_process_pdf_once(self, mock_print, mock_process_pdf, mock_input, mock_exists):\n        main()\n        mock_process_pdf.assert_called_once_with('valid.pdf')\n        mock_print.assert_any_call(\"Exiting the program.\")\n\n\n    @patch('os.path.exists', return_value=True)\n    @patch('builtins.input', side_effect=['valid.pdf', 'y', 'valid2.pdf', 'n'])\n    @patch('__main__.process_pdf')\n    @patch('builtins.print')\n    def test_main_process_pdf_twice(self, mock_print, mock_process_pdf, mock_input, mock_exists):\n        main()\n        self.assertEqual(mock_process_pdf.call_count, 2)\n        mock_process_pdf.assert_any_call('valid.pdf')\n        mock_process_pdf.assert_any_call('valid2.pdf')\n        mock_print.assert_any_call(\"Exiting the program.\")\n\n\n    @patch('__main__.get_pdf_text', return_value=\"Test PDF Content\")\n    @patch('__main__.get_text_chunks', return_value=['chunk1', 'chunk2'])\n    @patch('__main__.get_vector_store', return_value=True)\n    @patch('builtins.print')\n    def test_process_pdf_success(self, mock_print, mock_get_vector_store, mock_get_text_chunks, mock_get_pdf_text):\n        process_pdf(\"valid.pdf\")\n        mock_get_pdf_text.assert_called_once_with(\"valid.pdf\")\n        mock_get_text_chunks.assert_called_once_with(\"Test PDF Content\")\n        mock_get_vector_store.assert_called_once_with(['chunk1', 'chunk2'])\n        mock_print.assert_any_call(\"PDF processing complete. Knowledge base updated.\")\n\n    @patch('__main__.get_pdf_text', return_value=\"\")\n    @patch('builtins.print')\n    def test_process_pdf_no_text(self, mock_print, mock_get_pdf_text):\n        process_pdf(\"valid.pdf\")\n        mock_print.assert_any_call(\"No text extracted from PDF. Please check the file.\")\n\n    @patch('__main__.get_pdf_text', return_value=\"Test PDF Content\")\n    @patch('__main__.get_text_chunks', return_value=[])\n    @patch('builtins.print')\n    def test_process_pdf_no_chunks(self, mock_print, mock_get_text_chunks, mock_get_pdf_text):\n        process_pdf(\"valid.pdf\")\n        mock_print.assert_any_call(\"Failed to split text into chunks.\")\n\n    @patch('__main__.get_pdf_text', return_value=\"Test PDF Content\")\n    @patch('__main__.get_text_chunks', return_value=['chunk1', 'chunk2'])\n    @patch('__main__.get_vector_store', return_value=False)\n    @patch('builtins.print')\n    def test_process_pdf_vector_store_failure(self, mock_print, mock_get_vector_store, mock_get_text_chunks, mock_get_pdf_text):\n        process_pdf(\"valid.pdf\")\n        mock_print.assert_any_call(\"Failed to update knowledge base.\")\n\n    @patch('PyPDF2.PdfReader')\n    @patch('builtins.open', new_callable=mock_open, read_data=\"PDF Content\")\n    def test_get_pdf_text_success(self, mock_open, mock_pdf_reader):\n        mock_pdf_reader_instance = mock_pdf_reader.return_value\n        mock_pdf_reader_instance.pages = [type('Page', (object,), {'extract_text': lambda: \"Page Content\"})()]\n        result = get_pdf_text(\"valid.pdf\")\n        self.assertEqual(result, \"Page Content\")\n\n    @patch('PyPDF2.PdfReader', side_effect=Exception(\"PDF Error\"))\n    @patch('builtins.print')\n    def test_get_pdf_text_failure(self, mock_print, mock_pdf_reader):\n        result = get_pdf_text(\"invalid.pdf\")\n        self.assertEqual(result, \"\")\n        mock_print.assert_called_with(\"Error reading PDF invalid.pdf: PDF Error\")\n\n    def test_get_text_chunks_success(self):\n        text = \"This is a test. \" * 3000\n        chunks = get_text_chunks(text)\n        self.assertTrue(len(chunks) > 0)\n        self.assertTrue(all(len(chunk) <= 10000 for chunk in chunks))\n\n    def test_get_text_chunks_empty_text(self):\n        chunks = get_text_chunks(\"\")\n        self.assertEqual(chunks, [])\n\n    @patch('langchain.text_splitter.RecursiveCharacterTextSplitter.split_text', side_effect=Exception(\"Split Error\"))\n    @patch('builtins.print')\n    def test_get_text_chunks_failure(self, mock_print, mock_split_text):\n        chunks = get_text_chunks(\"test text\")\n        self.assertEqual(chunks, [])\n        mock_print.assert_called_with(\"Error splitting text: Split Error\")\n\n    @patch('langchain_google_genai.GoogleGenerativeAIEmbeddings')\n    @patch('langchain_community.vectorstores.FAISS.from_texts')\n    def test_get_vector_store_success(self, mock_from_texts, mock_embeddings):\n        mock_from_texts.return_value.save_local.return_value = None\n        self.assertTrue(get_vector_store([\"chunk1\", \"chunk2\"]))\n        mock_from_texts.assert_called_once()\n        mock_from_texts.return_value.save_local.assert_called_once_with(\"faiss_index\")\n\n    @patch('langchain_google_genai.GoogleGenerativeAIEmbeddings', side_effect=Exception(\"Embedding Error\"))\n    @patch('builtins.print')\n    def test_get_vector_store_failure(self, mock_print, mock_embeddings):\n        self.assertFalse(get_vector_store([\"chunk1\", \"chunk2\"]))\n        mock_print.assert_called_with(\"Error creating vector store: Embedding Error\")"
  }
}