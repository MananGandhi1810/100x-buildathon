{
  "app.py": {
    "language": "python",
    "test_cases": "import unittest\nimport os\nfrom unittest.mock import patch, MagicMock\nimport streamlit as st\nfrom streamlit_chat import message\nfrom langchain_google_genai import GoogleGenerativeAIEmbeddings\nimport google.generativeai as genai\nfrom langchain_community.vectorstores import FAISS\nfrom langchain_google_genai import ChatGoogleGenerativeAI\nfrom langchain.chains.question_answering import load_qa_chain\nfrom langchain.prompts import PromptTemplate\nfrom dotenv import load_dotenv\n\n# Mocking st.stop() to prevent the app from exiting during tests\n@patch('streamlit.stop')\ndef run_main_with_mocks(mock_stop):\n    # Ensure GOOGLE_API_KEY is set for testing purposes.  Set a default if not already set\n    if not os.getenv(\"GOOGLE_API_KEY\"):\n        os.environ[\"GOOGLE_API_KEY\"] = \"test_api_key\"  # Or a placeholder\n    from app import main  # Import here to ensure the environment variable is set before app import\n    main()\n\nclass TestApp(unittest.TestCase):\n\n    def setUp(self):\n        # Patch Streamlit's input and output functions\n        self.patcher_st_input = patch('streamlit.chat_input', return_value=\"test question\")\n        self.mock_st_input = self.patcher_st_input.start()\n        self.patcher_st_write = patch('streamlit.write')\n        self.mock_st_write = self.patcher_st_write.start()\n        self.patcher_st_spinner = patch('streamlit.spinner')\n        self.mock_st_spinner = self.patcher_st_spinner.start()\n        self.patcher_st_error = patch('streamlit.error')\n        self.mock_st_error = self.patcher_st_error.start()\n        self.patcher_st_selectbox = patch('streamlit.selectbox', return_value=\"English\")\n        self.mock_st_selectbox = self.patcher_st_selectbox.start()\n\n        # Ensure the API key is set for testing.  Use a default value if not provided\n        if not os.getenv(\"GOOGLE_API_KEY\"):\n            os.environ[\"GOOGLE_API_KEY\"] = \"test_api_key\"\n\n        # Mock the required external calls\n        self.patcher_load_dotenv = patch('dotenv.load_dotenv')\n        self.mock_load_dotenv = self.patcher_load_dotenv.start()\n\n        self.patcher_genai_configure = patch('google.generativeai.configure')\n        self.mock_genai_configure = self.patcher_genai_configure.start()\n\n\n    def tearDown(self):\n        self.patcher_st_input.stop()\n        self.patcher_st_write.stop()\n        self.patcher_st_spinner.stop()\n        self.patcher_st_error.stop()\n        self.patcher_st_selectbox.stop()\n        self.patcher_load_dotenv.stop()\n        self.patcher_genai_configure.stop()\n\n\n    @patch('app.ask_question')\n    def test_main_chat_interaction(self, mock_ask_question):\n        mock_ask_question.return_value = \"test response\"\n        run_main_with_mocks()\n\n        self.mock_st_write.assert_called()\n        self.mock_st_spinner.assert_called()\n        mock_ask_question.assert_called_with(\"test question\", \"English\")\n\n\n    @patch('app.ask_question')\n    def test_main_chat_interaction_with_error(self, mock_ask_question):\n        mock_ask_question.side_effect = Exception(\"test error\")\n        run_main_with_mocks()\n\n        self.mock_st_error.assert_called()\n        self.mock_st_spinner.assert_called()\n\n\n    @patch('app.FAISS.load_local')\n    @patch('app.ChatGoogleGenerativeAI')\n    @patch('app.load_qa_chain')\n    def test_ask_question_success(self, mock_load_qa_chain, mock_chat_model, mock_faiss_load):\n        mock_faiss_load.return_value.similarity_search.return_value = [\"document\"]\n        mock_chat_model.return_value = MagicMock()\n        mock_load_qa_chain.return_value.return_value = {'output_text': \"test answer\"}\n        result = app.ask_question(\"test question\", \"English\")\n\n        self.assertEqual(result, \"test answer\")\n        mock_load_qa_chain.assert_called()\n\n    @patch('app.FAISS.load_local')\n    @patch('app.ChatGoogleGenerativeAI')\n    @patch('app.load_qa_chain')\n    def test_ask_question_error(self, mock_load_qa_chain, mock_chat_model, mock_faiss_load):\n         mock_faiss_load.return_value.similarity_search.return_value = [\"document\"]\n         mock_chat_model.return_value = MagicMock()\n         mock_load_qa_chain.side_effect = Exception(\"test error\")\n\n         result = app.ask_question(\"test question\", \"English\")\n         self.assertIn(\"Error answering question\", result)\n\n\n    @patch('app.ChatGoogleGenerativeAI')\n    @patch('app.load_qa_chain')\n    def test_get_conversational_chain_success(self, mock_load_qa_chain, mock_chat_model):\n        mock_chat_model.return_value = MagicMock()\n        chain = app.get_conversational_chain()\n        self.assertIsNotNone(chain)\n        mock_load_qa_chain.assert_called()\n\n    @patch('app.ChatGoogleGenerativeAI')\n    @patch('app.load_qa_chain')\n    def test_get_conversational_chain_failure(self, mock_load_qa_chain, mock_chat_model):\n        mock_chat_model.side_effect = Exception(\"test error\")\n        chain = app.get_conversational_chain()\n        self.assertIsNone(chain)\n        self.mock_st_error.assert_called()\n\n    @patch('app.GoogleGenerativeAIEmbeddings')\n    def test_embeddings_initialization(self, mock_embeddings):\n        app.GoogleGenerativeAIEmbeddings(model=\"models/embedding-001\")\n        mock_embeddings.assert_called_with(model=\"models/embedding-001\")"
  },
  "add_pdfs.py": {
    "language": "python",
    "test_cases": "import unittest\nimport os\nfrom unittest.mock import patch, mock_open\nfrom io import StringIO\nfrom PyPDF2 import PdfReader\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\nfrom langchain_google_genai import GoogleGenerativeAIEmbeddings\nfrom langchain_community.vectorstores import FAISS\nimport google.generativeai as genai\nfrom dotenv import load_dotenv\nimport tempfile\nimport shutil\n\n# Assuming the code is in a file named 'pdf_processor.py'\nfrom pdf_processor import get_pdf_text, get_text_chunks, get_vector_store, process_pdf, main\n\nclass TestPDFProcessor(unittest.TestCase):\n\n    @classmethod\n    def setUpClass(cls):\n        load_dotenv()\n        cls.api_key = os.getenv(\"GOOGLE_API_KEY\")\n        if cls.api_key:\n            genai.configure(api_key=cls.api_key)\n        cls.temp_dir = tempfile.mkdtemp()\n\n    @classmethod\n    def tearDownClass(cls):\n        shutil.rmtree(cls.temp_dir)\n\n    def setUp(self):\n        self.test_pdf_content = \"This is a test PDF content.\\nMore content.\"\n        self.test_pdf_path = os.path.join(self.temp_dir, \"test.pdf\")\n        with open(self.test_pdf_path, \"w\") as f:\n            f.write(self.test_pdf_content)\n        self.empty_pdf_path = os.path.join(self.temp_dir, \"empty.pdf\")\n        with open(self.empty_pdf_path, \"w\") as f:\n            f.write(\"\")\n\n    def tearDown(self):\n        # Clean up any files created during tests\n        pass\n\n\n    def test_get_pdf_text_success(self):\n        text = get_pdf_text(self.test_pdf_path)\n        self.assertIn(\"This is a test PDF content.\", text)\n\n    def test_get_pdf_text_failure(self):\n        text = get_pdf_text(\"nonexistent.pdf\")\n        self.assertEqual(text, \"\")\n\n    def test_get_pdf_text_empty_file(self):\n        text = get_pdf_text(self.empty_pdf_path)\n        self.assertEqual(text, \"\")\n\n    def test_get_text_chunks_success(self):\n        chunks = get_text_chunks(self.test_pdf_content)\n        self.assertTrue(isinstance(chunks, list))\n        self.assertGreater(len(chunks), 0)\n        self.assertIn(\"This is a test PDF content.\", chunks[0])\n\n    def test_get_text_chunks_empty_input(self):\n        chunks = get_text_chunks(\"\")\n        self.assertEqual(chunks, [])\n\n    @unittest.skipUnless(os.getenv(\"GOOGLE_API_KEY\"), \"Requires GOOGLE_API_KEY\")\n    def test_get_vector_store_success(self):\n        chunks = [\"Test chunk 1\", \"Test chunk 2\"]\n        result = get_vector_store(chunks)\n        self.assertTrue(result)\n        # Clean up: Remove the FAISS index file after the test\n        if os.path.exists(\"faiss_index\"):\n            shutil.rmtree(\"faiss_index\")\n\n\n    @unittest.skipUnless(os.getenv(\"GOOGLE_API_KEY\"), \"Requires GOOGLE_API_KEY\")\n    def test_get_vector_store_failure(self):\n        with patch('langchain_community.vectorstores.faiss.FAISS.from_texts') as mock_from_texts:\n            mock_from_texts.side_effect = Exception(\"Simulated error\")\n            chunks = [\"Test chunk\"]\n            result = get_vector_store(chunks)\n            self.assertFalse(result)\n\n    @unittest.skipUnless(os.getenv(\"GOOGLE_API_KEY\"), \"Requires GOOGLE_API_KEY\")\n    def test_process_pdf_success(self):\n        with patch('pdf_processor.get_pdf_text') as mock_get_pdf_text:\n            with patch('pdf_processor.get_text_chunks') as mock_get_text_chunks:\n                with patch('pdf_processor.get_vector_store') as mock_get_vector_store:\n                    mock_get_pdf_text.return_value = self.test_pdf_content\n                    mock_get_text_chunks.return_value = [\"chunk1\", \"chunk2\"]\n                    mock_get_vector_store.return_value = True\n                    process_pdf(self.test_pdf_path)\n                    mock_get_pdf_text.assert_called_once_with(self.test_pdf_path)\n                    mock_get_text_chunks.assert_called_once()\n                    mock_get_vector_store.assert_called_once()\n\n    @unittest.skipUnless(os.getenv(\"GOOGLE_API_KEY\"), \"Requires GOOGLE_API_KEY\")\n    def test_process_pdf_no_text(self):\n        with patch('pdf_processor.get_pdf_text') as mock_get_pdf_text:\n            mock_get_pdf_text.return_value = \"\"\n            with patch('builtins.print') as mock_print:\n                process_pdf(self.test_pdf_path)\n                mock_print.assert_any_call(\"No text extracted from PDF. Please check the file.\")\n\n    @unittest.skipUnless(os.getenv(\"GOOGLE_API_KEY\"), \"Requires GOOGLE_API_KEY\")\n    def test_process_pdf_no_chunks(self):\n        with patch('pdf_processor.get_pdf_text') as mock_get_pdf_text:\n            with patch('pdf_processor.get_text_chunks') as mock_get_text_chunks:\n                mock_get_pdf_text.return_value = \"Some text\"\n                mock_get_text_chunks.return_value = []\n                with patch('builtins.print') as mock_print:\n                    process_pdf(self.test_pdf_path)\n                    mock_print.assert_any_call(\"Failed to split text into chunks.\")\n\n    @unittest.skipUnless(os.getenv(\"GOOGLE_API_KEY\"), \"Requires GOOGLE_API_KEY\")\n    def test_process_pdf_vector_store_failure(self):\n        with patch('pdf_processor.get_pdf_text') as mock_get_pdf_text:\n            with patch('pdf_processor.get_text_chunks') as mock_get_text_chunks:\n                with patch('pdf_processor.get_vector_store') as mock_get_vector_store:\n                    mock_get_pdf_text.return_value = \"Some text\"\n                    mock_get_text_chunks.return_value = [\"chunk1\"]\n                    mock_get_vector_store.return_value = False\n                    with patch('builtins.print') as mock_print:\n                        process_pdf(self.test_pdf_path)\n                        mock_print.assert_any_call(\"Failed to update knowledge base.\")\n\n    @patch('builtins.input', side_effect=['q'])\n    @patch('builtins.print')\n    def test_main_quits_on_q(self, mock_print, mock_input):\n        main()\n        mock_print.assert_any_call(\"Exiting the program.\")\n\n    @patch('builtins.input', side_effect=['nonexistent.pdf', 'q'])\n    @patch('builtins.print')\n    def test_main_handles_file_not_found(self, mock_print, mock_input):\n        main()\n        mock_print.assert_any_call(\"File not found: nonexistent.pdf\")\n        mock_print.assert_any_call(\"Exiting the program.\")\n\n\n    @patch('builtins.input', side_effect=[f'{os.path.join(self.temp_dir, \"test.pdf\")}', 'n'])\n    @patch('pdf_processor.process_pdf')\n    def test_main_processes_one_pdf_and_quits(self, mock_process_pdf, mock_input):\n        main()\n        mock_process_pdf.assert_called_once()\n        mock_process_pdf.assert_called_with(f'{os.path.join(self.temp_dir, \"test.pdf\")}')\n\n\n    @patch('builtins.input', side_effect=[f'{os.path.join(self.temp_dir, \"test.pdf\")}', 'y', 'q'])\n    @patch('pdf_processor.process_pdf')\n    def test_main_processes_multiple_pdfs_and_quits(self, mock_process_pdf, mock_input):\n        main()\n        self.assertEqual(mock_process_pdf.call_count, 1)\n        mock_process_pdf.assert_called_with(f'{os.path.join(self.temp_dir, \"test.pdf\")}')"
  }
}